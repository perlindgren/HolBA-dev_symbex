# 2 Transpiling Program to BIR
A binary program is transpiled (or "lifted") by executing
```
val _ = lift_da_and_store "add_reg"
                          "../1-code/src/add_reg.da"
                          ((Arbnum.fromInt 0), (Arbnum.fromInt 0x1000000));
```
The parameters of this functions are:
* "add_reg": string representing the name of the HOL4 term that will
  be defined to be equal to the transpiled program
* "../1-code/src/add_reg.da": path of the disassembled program
* ((Arbnum.fromInt 0), (Arbnum.fromInt 0x1000000)): superset of the
  addresses that contains the program code. We call this memory region
  `UnmodifiableMemory`.

Transpilation of the example is executed using the command `make
examples/tutorial/2-lift`, which transpiles the program and generates
the corresponding `examplesBinaryTheory`.

File `tutorial_liftScript.sml` demonstrates the theorems obtained by
the transpiler.

## Transpiler program
The transpiled program is in the term ``bir_add_reg_prog``. The list of
statements can be obtained by executing
```
val blocks = (fst o listSyntax.dest_list o dest_BirProgram o snd o dest_eq o concl o EVAL) ``bir_add_reg_prog``;
```
The first block (i.e. `(el 1)blocks`) implements the stack allocation (i.e. `sub	sp, sp, #0x10`):
```
<|bb_label := BL_Address (Imm64 0w);
      bb_statements :=
        [BStmt_Assign (BVar "SP_EL0" (BType_Imm Bit64))
           (BExp_BinExp BIExp_Minus
              (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
              (BExp_Const (Imm64 16w)))];
      bb_last_statement := BStmt_Jmp (BLE_Label (BL_Address (Imm64 4w)))|>
```
Each block has a unique label (i.e. `BL_Address (Imm64 0w)`). In this
case the label is an integer, which is equal to the address of the
corresponding transpiled instruction. Labels can also be strings, for
example when the block represents internal computations of an
instruction or is generated by some program transformations (i.e. loop
unrolling).

A block has an internal list of statements, which are executed
sequentially. In this case there is only one statement, which decreases
the variable `SP_EL0` (of type `Bit64`) by `16`.

Finally, a block always ends with a control flow statement. In this
case, the block jumps to the next block, i.e. the block having label
`BL_Address (Imm64 4w)`. Notice that it is not possible to jump to the
middle of a block. 

The second block (i.e. `(el 2)blocks`) implements storing the first
parameter on the stack (i.e. `str	x0, [sp, #8]`):
```
<|bb_label := BL_Address (Imm64 4w);
      bb_statements :=
        [BStmt_Assert
           (BExp_BinPred BIExp_Equal
              (BExp_BinExp BIExp_And
                 (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                 (BExp_Const (Imm64 7w))) (BExp_Const (Imm64 0w)));
         BStmt_Assert
           (BExp_BinExp BIExp_And
              (BExp_BinPred BIExp_LessOrEqual
                 (BExp_BinExp BIExp_Plus
                    (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                    (BExp_Const (Imm64 8w)))
                 (BExp_Const (Imm64 0xFFFFFFFFFFFFFFF7w)))
              (BExp_BinExp BIExp_And
                 (BExp_BinExp BIExp_Or
                    (BExp_BinPred BIExp_LessThan (BExp_Const (Imm64 0w))
                       (BExp_BinExp BIExp_Plus
                          (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                          (BExp_Const (Imm64 8w))))
                    (BExp_BinPred BIExp_LessOrEqual
                       (BExp_BinExp BIExp_Plus (BExp_Const (Imm64 8w))
                          (BExp_BinExp BIExp_Plus
                             (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                             (BExp_Const (Imm64 8w))))
                       (BExp_Const (Imm64 0w))))
                 (BExp_BinExp BIExp_Or
                    (BExp_BinPred BIExp_LessThan
                       (BExp_BinExp BIExp_Plus
                          (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                          (BExp_Const (Imm64 8w))) (BExp_Const (Imm64 0w)))
                    (BExp_BinPred BIExp_LessOrEqual
                       (BExp_Const (Imm64 0x1000000w))
                       (BExp_BinExp BIExp_Plus
                          (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                          (BExp_Const (Imm64 8w)))))));
         BStmt_Assign (BVar "MEM" (BType_Mem Bit64 Bit8))
           (BExp_Store (BExp_Den (BVar "MEM" (BType_Mem Bit64 Bit8)))
              (BExp_BinExp BIExp_Plus
                 (BExp_Den (BVar "SP_EL0" (BType_Imm Bit64)))
                 (BExp_Const (Imm64 8w))) BEnd_LittleEndian
              (BExp_Den (BVar "R0" (BType_Imm Bit64))))];
      bb_last_statement := BStmt_Jmp (BLE_Label (BL_Address (Imm64 8w)))|>
```
Notice that the execution of this block can fail:
* If the stack pointer is not 8 byte aligned, then the ARM8 store semantics
  is undefined.
* If the program stores into the `UnmodifiableMemory` then it may
  override the program code

This allows us to ensure that non-failing executions of the BIR
program are equivalents to executions of the original ARMv8 program.

Notice that `MEM` is a variable: a map from 64 bit integers to bytes.
A memory store is an expression, which generates a new memory that is
saved into the variable `MEM`. BIR allows several memory variables.

The block `(el ((0x3c div 4)+1))blocks` updates the flags for computing
the loop condition (i.e. `cmp	x0, #0x0`). 
```
<|bb_label := BL_Address (Imm64 60w);
      bb_statements :=
        [BStmt_Assign (BVar "ProcState_C" (BType_Imm Bit1))
           (BExp_Const (Imm1 1w));
         BStmt_Assign (BVar "ProcState_N" (BType_Imm Bit1))
           (BExp_BinPred BIExp_SignedLessThan
              (BExp_Den (BVar "R0" (BType_Imm Bit64)))
              (BExp_Const (Imm64 0w)));
         BStmt_Assign (BVar "ProcState_V" (BType_Imm Bit1))
           (BExp_Const (Imm1 0w));
         BStmt_Assign (BVar "ProcState_Z" (BType_Imm Bit1))
           (BExp_BinPred BIExp_Equal (BExp_Den (BVar "R0" (BType_Imm Bit64)))
              (BExp_Const (Imm64 0w)))];
      bb_last_statement := BStmt_Jmp (BLE_Label (BL_Address (Imm64 64w)))|>
```
Notice that several flags are updated.

Block `(el ((0x40 div 4)+1))blocks` implements the conditional jump
`b.gt 20`:
```
<|bb_label := BL_Address (Imm64 64w); bb_statements := [];
      bb_last_statement :=
        BStmt_CJmp
          (BExp_BinExp BIExp_Or
             (BExp_UnaryExp BIExp_Not
                (BExp_BinPred BIExp_Equal
                   (BExp_Den (BVar "ProcState_N" (BType_Imm Bit1)))
                   (BExp_Den (BVar "ProcState_V" (BType_Imm Bit1)))))
             (BExp_Den (BVar "ProcState_Z" (BType_Imm Bit1))))
          (BLE_Label (BL_Address (Imm64 68w)))
          (BLE_Label (BL_Address (Imm64 32w)))|>
```
Notice that due to internals of the ARMv8 semantics the transpiled
block exit the loops if the condition holds. That is, the BIR
condition is actually the negation of the condition of `branch
greather than`.

Even if we will not verify the last instruction, the block `(el ((0x4c
div 4)+1))blocks` models the function's return (i.e. `ret`).
```
<|bb_label := BL_Address (Imm64 76w); bb_statements := [];
      bb_last_statement :=
        BStmt_Jmp (BLE_Exp (BExp_Den (BVar "R30" (BType_Imm Bit64))))|>
```
Notice that this block ends with an indirect jump.


## Transpiler theorem
`bir_add_reg_arm8_lift_THM` is the main theorem and states that the
program has been correctly transpiled. 
```
bir_is_lifted_prog arm8_bmr (WI_end 0w 0x1000000w) bir_add_reg_progbin
  bir_add_reg_prog 
```
which formally means 
```
bir_is_lifted_prog r mu mms p =
  (WI_wfe mu ∧
   EVERY
     (λmm.
	  WF_bmr_ms_mem_contains mm ∧
	  WI_is_sub (bmr_ms_mem_contains_interval mm) mu) mms ∧
   bir_is_valid_labels p ∧ bir_program_string_labels_guarded p) ∧
  ∀ms bs li.
      bmr_rel r bs ms ⇒
      MEM (BL_Address li) (bir_labels_of_program p) ⇒
      (bs.bst_pc = bir_block_pc (BL_Address li)) ⇒
      EVERY (bmr_ms_mem_contains r ms) mms ⇒
      ¬bir_state_is_terminated bs ⇒
      ∃lo c_st c_addr_labels bs'.
	  (bir_exec_to_addr_label p bs =
	   BER_Ended lo c_st c_addr_labels bs') ∧
	  (bs'.bst_status ≠ BST_AssertionViolated ⇒
	   ∃ms'.
	       (r.bmr_step_fun ms = SOME ms') ∧
	       bmr_ms_mem_unchanged r ms ms' mu ∧ bmr_rel r bs' ms')
```
* The first part of the definition guarantees some well-formedness
properties:
  *  The `UnmodifiableMemory` range `mu` is well-formed (i.e. it does not
overlap. it is aligned, etc.)
  * all instructions of the binary program `mms` are contained in the `UnmodifiableMemory`, 
  * the transpiled program `p` does not contain duplicated labels
* The second part demonstrates the bisimulation (these are
  deterministic LTS) when the BIR program does not fail.
* The theorem also demonstrates that the `UnmodifiableMemory` is
  unchanged. This is needed for compositionality of multiple
  instructions.
* `bir_exec_to_addr_label` is a sort of weak transition relation that
  hides all intermediary blocks that do not represent the entry point
  of an ARMv8 instruction (i.e. blocks that have string label).


The relation `bmr_rel arm8_bmr bs ms` ensures that the BIR and ARMv8
states match each other, e.g.:
```
(bir_env_read (BVar "ProcState_C" (BType_Imm Bit1)) bs.bst_environ =
   BVal_Imm (bool2b ms.PSTATE.C)) ∧
   ...
(bir_env_read (BVar "R0" (BType_Imm Bit64)) bs.bst_environ =
   BVal_Imm (Imm64 (ms.REG 0w))) ∧
   ...
(bir_env_read (BVar "SP_EL0" (BType_Imm Bit64)) bs.bst_environ =
   BVal_Imm (Imm64 ms.SP_EL0)) ∧
   ...
((bs.bst_pc = bir_block_pc (BL_Address (Imm64 ms.PC))) ∧
   (bs.bst_status = BST_Running) ∨
   (bs.bst_status = BST_JumpOutside (BL_Address (Imm64 ms.PC)))) ∧
   ...
(∃mem_n.
       (bir_env_read (BVar "MEM" (BType_Mem Bit64 Bit8)) bs.bst_environ =
        BVal_Mem Bit64 Bit8 mem_n) ∧
       (ms.MEM = (λa. n2w (bir_load_mmap mem_n (w2n a)))))
```
It also ensures some properties of the ARMv8 state
```
  ¬ms.SCTLR_EL1.E0E ∧ (ms.PSTATE.EL = 0w) ∧ (ms.exception = NoException) ∧
  ¬ms.SCTLR_EL1.SA0 ∧ ¬ms.TCR_EL1.TBI0 ∧ ¬ms.TCR_EL1.TBI1
```
and that the BIR state has some variables that could be used
internally by the lifter
```
  bir_env_var_is_declared bs.bst_environ
    (BVar "tmp_ProcState_C" (BType_Imm Bit1)) ∧
...
  bir_env_var_is_declared bs.bst_environ (BVar "tmp_R0" (BType_Imm Bit64)) ∧
...
```

The lifter theorem can be composed for multi-step executions `bir_inst_liftingTheory.bir_is_lifted_prog_MULTI_STEP_EXEC`:
```
∀r mu mms p.
      bir_is_lifted_prog r mu mms p ⇒
      ∀n ms bs.
          bmr_rel r bs ms ⇒
          (∃li.
               MEM (BL_Address li) (bir_labels_of_program p) ∧
               (bs.bst_pc = bir_block_pc (BL_Address li))) ⇒
          EVERY (bmr_ms_mem_contains r ms) mms ⇒
          ¬bir_state_is_terminated bs ⇒
          ∃lo c_st c_addr_labels bs'.
              (bir_exec_to_addr_label_n p bs n =
               BER_Ended lo c_st c_addr_labels bs') ∧
              (bs'.bst_status ≠ BST_AssertionViolated ⇒
               ∃ms'.
                   (FUNPOW_OPT r.bmr_step_fun c_addr_labels ms = SOME ms') ∧
                   bmr_ms_mem_unchanged r ms ms' mu ∧
                   EVERY (bmr_ms_mem_contains r ms') mms ∧
                   (case bs'.bst_status of
                      BST_Running =>
                        ∃li.
                            MEM (BL_Address li) (bir_labels_of_program p) ∧
                            (bs'.bst_pc = bir_block_pc (BL_Address li))
                    | BST_Failed => F
                    | BST_AssumptionViolated => F
                    | BST_AssertionViolated => F
                    | BST_Halted v2 => F
                    | BST_JumpOutside ll =>
                      ¬MEM ll (bir_labels_of_program p) ∧ IS_BL_Address ll) ∧
                   bmr_rel r bs' ms')
```
